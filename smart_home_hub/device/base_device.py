from abc import ABCMeta, abstractmethod
from copy import deepcopy
from marshmallow import fields
from typing import List, Dict

from ..utils.utils import DescClass


class EarlyExitError(Exception):
    """
    Exception to raise and catch by the main thread indicating there was a
    problem running the action as expected.
    """


class DeviceAction(DescClass, metaclass=ABCMeta):
    """
    An Action that can be taken on a device. Specifies what arguments can
    be given, and what response will occur.

    These objects will be used by devices to be interacted with via the 2 main
    control options (API & VUI).

    _name must be specified (and be unique)
    _desc can be specified to give information on the action performed.
    """
    def __init__(self, device):
        super().__init__()
        self.device = device
        self.args = {}
        self.resp = {
            'message': '',
            'status': 0
        }

    def init_args(self, **kwargs):
        """
        Initializes the action with any args passed
        (these args are specified by the argmap)
        """
        # TODO: Some kind of argument check here that the args are from argmap
        self.args = deepcopy(kwargs)

    @abstractmethod
    def argmap(self) -> dict:
        """
        Returns a dict containing marshmallow fields on what type of arguments
        are expected to call this action (will be passed to constructor)
        """
        return {}

    def response(self) -> dict:
        """
        Returns a JSON serializable dict, which must include 'message' as
        a key.
        """
        return self.resp

    def set_msg(self, new_msg, exit_early=False):
        """
        Sets the message of the response with a new string
        """
        self.resp['message'] = new_msg
        if exit_early:
            self.resp['status'] = 1

    @abstractmethod
    def perform(self):
        """
        Performs the action. Main code goes here.

        NOTE: Should also set self.resp here, unless you want to override
              self.response()
        """

    def perform_other_action(
            self,
            action_name: str,
            raise_for_status=True,
            **action_args
    ):
        """
        Performs the action specified (if found in the device's action map).
        This functionality is included to make DeviceActions act like functions
        i.e. they can call one another
        :param action_name: Name of action to invoke
        :param raise_for_status: Whether to raise an EarlyExitError if the
                                 other_action returned a non-zero status
        :param action_args: Any named arguments to set for the action
        :return: The response generated by performing the other action
        """
        other_action = self.device.action_map()[action_name]
        other_action.init_args(**action_args)
        other_action.perform()
        resp = other_action.response()

        if resp['status'] > 0 and raise_for_status:
            self.set_msg(resp['message'])
            raise EarlyExitError()
        else:
            return resp


class ListActions(DeviceAction):
    """
    An action that all devices should have, which lists the actions available
    to the device in the response.
    """
    _name = 'list_actions'

    def argmap(self) -> dict:
        return {}

    def perform(self):
        self.set_msg(
            ', '.join(self.device.action_names())
        )


class ListActionArgs(DeviceAction):
    """
    An action that all devices should have, which lists the arguments available
    to the action specified.
    """
    _name = 'list_arguments'

    def argmap(self):
        return {
            'action': fields.Str(
                required=True,
                voice_ndx=0
            )
        }

    def perform(self):
        # TODO: Make this more descriptive? Maybe list the requirements too
        self.set_msg(
            ', '.join(
                self.device.action_map()[
                    self.args['action'].lower()
                ].argmap().keys()
            )
        )


class Device(DescClass, metaclass=ABCMeta):
    """
    Device class that is used for interacting with a device. Contains
    information (usually URL's and any API keys) for contacting the device,
    and a list of actions that can be performed.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    @classmethod
    def dev_name(cls):
        return cls._name

    @classmethod
    def dev_desc(cls):
        return cls._desc

    @abstractmethod
    def actions(self) -> List[DeviceAction]:
        """
        Should return a list of all available actions for this device
        """
        return [
            ListActions(self),
            ListActionArgs(self)
        ]

    def action_names(self) -> List[str]:
        """
        Returns a list of the action names for the device
        """
        return [
            action.name for action in self.actions()
        ]

    def action_map(self) -> Dict[str, DeviceAction]:
        """
        Returns a map of name: Action pairs for this device
        """
        action_map = {}

        for action in self.actions():
            if action.name in action_map:
                raise ValueError(f'Non-unique name {action.name} for Action')

            action_map[action.name] = action

        return action_map
